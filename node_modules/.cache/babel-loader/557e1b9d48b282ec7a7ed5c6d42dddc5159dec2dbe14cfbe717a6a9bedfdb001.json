{"ast":null,"code":"// frontend-service/src/services/auth.js\nimport { jwtDecode } from 'jwt-decode';\nimport axios from 'axios';\n\n// Check if the token is expired\nexport const isTokenExpired = token => {\n  if (!token) return true;\n  const {\n    exp\n  } = jwtDecode(token);\n  const currentTime = Math.floor(Date.now() / 1000);\n  return exp < currentTime;\n};\n\n// Store tokens securely\nexport const storeTokens = (accessToken, idToken, refreshToken, rememberMe = false) => {\n  if (rememberMe) {\n    localStorage.setItem('accessToken', accessToken);\n    localStorage.setItem('idToken', idToken);\n  } else {\n    sessionStorage.setItem('accessToken', accessToken);\n    sessionStorage.setItem('idToken', idToken);\n  }\n\n  // Backend should handle setting the refreshToken in a HttpOnly cookie\n  document.cookie = `refreshToken=${refreshToken}; HttpOnly; Secure; SameSite=Strict`;\n};\n\n// Refresh tokens\nexport const refreshAccessToken = async (email, refreshToken) => {\n  try {\n    const response = await axios.post('/refresh', {\n      email,\n      refresh_token: refreshToken\n    },\n    // Include email and refresh_token in the request body\n    {\n      withCredentials: true\n    } // Include credentials if required\n    );\n    const {\n      accessToken,\n      idToken\n    } = response.data;\n\n    // Update tokens in storage\n    sessionStorage.setItem('accessToken', accessToken);\n    sessionStorage.setItem('idToken', idToken);\n    return accessToken; // Return the new access token\n  } catch (error) {\n    console.error('Token refresh failed', error);\n    throw error; // Propagate the error for the caller to handle\n  }\n};\nexport const clearTokens = () => {\n  sessionStorage.removeItem('accessToken');\n  sessionStorage.removeItem('idToken');\n  localStorage.removeItem('accessToken');\n  localStorage.removeItem('idToken');\n  document.cookie = 'refreshToken=; Max-Age=0; Secure; SameSite=Strict';\n};","map":{"version":3,"names":["jwtDecode","axios","isTokenExpired","token","exp","currentTime","Math","floor","Date","now","storeTokens","accessToken","idToken","refreshToken","rememberMe","localStorage","setItem","sessionStorage","document","cookie","refreshAccessToken","email","response","post","refresh_token","withCredentials","data","error","console","clearTokens","removeItem"],"sources":["/Users/pbh7080/Desktop/project/ITeaMoa/frontend-service/src/services/auth.js"],"sourcesContent":["// frontend-service/src/services/auth.js\nimport {jwtDecode} from 'jwt-decode';\nimport axios from 'axios';\n\n// Check if the token is expired\nexport const isTokenExpired = (token) => {\n    if (!token) return true;\n    const { exp } = jwtDecode(token);\n    const currentTime = Math.floor(Date.now() / 1000);\n    return exp < currentTime;\n};\n\n// Store tokens securely\nexport const storeTokens = (accessToken, idToken, refreshToken, rememberMe = false) => {\n    if (rememberMe) {\n        localStorage.setItem('accessToken', accessToken);\n        localStorage.setItem('idToken', idToken);\n    } else {\n        sessionStorage.setItem('accessToken', accessToken);\n        sessionStorage.setItem('idToken', idToken);\n    }\n\n    // Backend should handle setting the refreshToken in a HttpOnly cookie\n    document.cookie = `refreshToken=${refreshToken}; HttpOnly; Secure; SameSite=Strict`;\n};\n\n// Refresh tokens\nexport const refreshAccessToken = async (email, refreshToken) => {\n    try {\n        const response = await axios.post(\n            '/refresh',\n            { email, refresh_token: refreshToken }, // Include email and refresh_token in the request body\n            { withCredentials: true } // Include credentials if required\n        );\n\n        const { accessToken, idToken } = response.data;\n\n        // Update tokens in storage\n        sessionStorage.setItem('accessToken', accessToken);\n        sessionStorage.setItem('idToken', idToken);\n\n        return accessToken; // Return the new access token\n    } catch (error) {\n        console.error('Token refresh failed', error);\n        throw error; // Propagate the error for the caller to handle\n    }\n};\n\nexport const clearTokens = () => {\n    sessionStorage.removeItem('accessToken');\n    sessionStorage.removeItem('idToken');\n    localStorage.removeItem('accessToken');\n    localStorage.removeItem('idToken');\n\n    document.cookie = 'refreshToken=; Max-Age=0; Secure; SameSite=Strict';\n};"],"mappings":"AAAA;AACA,SAAQA,SAAS,QAAO,YAAY;AACpC,OAAOC,KAAK,MAAM,OAAO;;AAEzB;AACA,OAAO,MAAMC,cAAc,GAAIC,KAAK,IAAK;EACrC,IAAI,CAACA,KAAK,EAAE,OAAO,IAAI;EACvB,MAAM;IAAEC;EAAI,CAAC,GAAGJ,SAAS,CAACG,KAAK,CAAC;EAChC,MAAME,WAAW,GAAGC,IAAI,CAACC,KAAK,CAACC,IAAI,CAACC,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC;EACjD,OAAOL,GAAG,GAAGC,WAAW;AAC5B,CAAC;;AAED;AACA,OAAO,MAAMK,WAAW,GAAGA,CAACC,WAAW,EAAEC,OAAO,EAAEC,YAAY,EAAEC,UAAU,GAAG,KAAK,KAAK;EACnF,IAAIA,UAAU,EAAE;IACZC,YAAY,CAACC,OAAO,CAAC,aAAa,EAAEL,WAAW,CAAC;IAChDI,YAAY,CAACC,OAAO,CAAC,SAAS,EAAEJ,OAAO,CAAC;EAC5C,CAAC,MAAM;IACHK,cAAc,CAACD,OAAO,CAAC,aAAa,EAAEL,WAAW,CAAC;IAClDM,cAAc,CAACD,OAAO,CAAC,SAAS,EAAEJ,OAAO,CAAC;EAC9C;;EAEA;EACAM,QAAQ,CAACC,MAAM,GAAG,gBAAgBN,YAAY,qCAAqC;AACvF,CAAC;;AAED;AACA,OAAO,MAAMO,kBAAkB,GAAG,MAAAA,CAAOC,KAAK,EAAER,YAAY,KAAK;EAC7D,IAAI;IACA,MAAMS,QAAQ,GAAG,MAAMrB,KAAK,CAACsB,IAAI,CAC7B,UAAU,EACV;MAAEF,KAAK;MAAEG,aAAa,EAAEX;IAAa,CAAC;IAAE;IACxC;MAAEY,eAAe,EAAE;IAAK,CAAC,CAAC;IAC9B,CAAC;IAED,MAAM;MAAEd,WAAW;MAAEC;IAAQ,CAAC,GAAGU,QAAQ,CAACI,IAAI;;IAE9C;IACAT,cAAc,CAACD,OAAO,CAAC,aAAa,EAAEL,WAAW,CAAC;IAClDM,cAAc,CAACD,OAAO,CAAC,SAAS,EAAEJ,OAAO,CAAC;IAE1C,OAAOD,WAAW,CAAC,CAAC;EACxB,CAAC,CAAC,OAAOgB,KAAK,EAAE;IACZC,OAAO,CAACD,KAAK,CAAC,sBAAsB,EAAEA,KAAK,CAAC;IAC5C,MAAMA,KAAK,CAAC,CAAC;EACjB;AACJ,CAAC;AAED,OAAO,MAAME,WAAW,GAAGA,CAAA,KAAM;EAC7BZ,cAAc,CAACa,UAAU,CAAC,aAAa,CAAC;EACxCb,cAAc,CAACa,UAAU,CAAC,SAAS,CAAC;EACpCf,YAAY,CAACe,UAAU,CAAC,aAAa,CAAC;EACtCf,YAAY,CAACe,UAAU,CAAC,SAAS,CAAC;EAElCZ,QAAQ,CAACC,MAAM,GAAG,mDAAmD;AACzE,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}