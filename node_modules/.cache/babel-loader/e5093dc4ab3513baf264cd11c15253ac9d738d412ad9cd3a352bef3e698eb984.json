{"ast":null,"code":"// frontend-service/src/services/auth.js\nimport { jwtDecode } from 'jwt-decode';\nimport axios from 'axios';\n\n// Check if the token is expired\nexport const isTokenExpired = token => {\n  if (!token) {\n    console.error('Invalid token format:', token);\n    return true; // Consider invalid tokens as expired\n  }\n  try {\n    const {\n      exp\n    } = jwtDecode(token);\n    const currentTime = Math.floor(Date.now() / 1000);\n    return exp < currentTime;\n  } catch (error) {\n    console.error('Error decoding token:', error);\n    return true; // Treat decoding errors as expired tokens\n  }\n};\n\n// Store tokens securely\nexport const storeTokens = (accessToken, idToken, refreshToken, rememberMe = false) => {\n  if (rememberMe) {\n    localStorage.setItem('accessToken', accessToken);\n    localStorage.setItem('idToken', idToken);\n  } else {\n    sessionStorage.setItem('accessToken', accessToken);\n    sessionStorage.setItem('idToken', idToken);\n  }\n  console.log('Stored Access Token:', sessionStorage.getItem('accessToken'));\n  console.log('Stored ID Token:', sessionStorage.getItem('idToken'));\n\n  // If the backend does not set the cookie, fallback to this (not HttpOnly)\n  if (refreshToken) {\n    console.log('Storing refresh token in cookie:', refreshToken);\n    document.cookie = `refreshToken=${refreshToken}; Secure; SameSite=Strict; Path=/;`;\n  } else {\n    console.warn('No refresh token provided!');\n  }\n};\n\n// Refresh tokens\nexport const refreshAccessToken = async (email, refreshToken) => {\n  try {\n    const response = await axios.post('/refresh', {\n      email,\n      refresh_token: refreshToken\n    } // Include email and refresh_token in the request body\n    // { withCredentials: true } // Include credentials if required\n    );\n    const {\n      accessToken,\n      idToken\n    } = response.data;\n\n    // Update tokens in storage\n    sessionStorage.setItem('accessToken', accessToken);\n    sessionStorage.setItem('idToken', idToken);\n    return accessToken; // Return the new access token\n  } catch (error) {\n    console.error('Token refresh failed', error);\n    throw error; // Propagate the error for the caller to handle\n  }\n};\nexport const clearTokens = () => {\n  sessionStorage.removeItem('accessToken');\n  sessionStorage.removeItem('idToken');\n  localStorage.removeItem('accessToken');\n  localStorage.removeItem('idToken');\n  document.cookie = 'refreshToken=; Max-Age=0; Secure; SameSite=Strict';\n};","map":{"version":3,"names":["jwtDecode","axios","isTokenExpired","token","console","error","exp","currentTime","Math","floor","Date","now","storeTokens","accessToken","idToken","refreshToken","rememberMe","localStorage","setItem","sessionStorage","log","getItem","document","cookie","warn","refreshAccessToken","email","response","post","refresh_token","data","clearTokens","removeItem"],"sources":["/Users/pbh7080/Desktop/project/ITeaMoa/frontend-service/src/services/auth.js"],"sourcesContent":["// frontend-service/src/services/auth.js\nimport {jwtDecode} from 'jwt-decode';\nimport axios from 'axios';\n\n// Check if the token is expired\nexport const isTokenExpired = (token) => {\n    if (!token) {\n        console.error('Invalid token format:', token);\n        return true; // Consider invalid tokens as expired\n    }\n\n    try {\n        const { exp } = jwtDecode(token);\n        const currentTime = Math.floor(Date.now() / 1000);\n        return exp < currentTime;\n    } catch (error) {\n        console.error('Error decoding token:', error);\n        return true; // Treat decoding errors as expired tokens\n    }\n};\n\n// Store tokens securely\nexport const storeTokens = (accessToken, idToken, refreshToken, rememberMe = false) => {\n    if (rememberMe) {\n        localStorage.setItem('accessToken', accessToken);\n        localStorage.setItem('idToken', idToken);\n    } else {\n        sessionStorage.setItem('accessToken', accessToken);\n        sessionStorage.setItem('idToken', idToken);\n    }\n\n    console.log('Stored Access Token:', sessionStorage.getItem('accessToken'));\n    console.log('Stored ID Token:', sessionStorage.getItem('idToken'));\n\n    // If the backend does not set the cookie, fallback to this (not HttpOnly)\n    if (refreshToken) {\n        console.log('Storing refresh token in cookie:', refreshToken);\n        document.cookie = `refreshToken=${refreshToken}; Secure; SameSite=Strict; Path=/;`;\n      } else {\n        console.warn('No refresh token provided!');\n      }\n};\n\n// Refresh tokens\nexport const refreshAccessToken = async (email, refreshToken) => {\n    try {\n        const response = await axios.post(\n            '/refresh',\n            { email, refresh_token: refreshToken }, // Include email and refresh_token in the request body\n            // { withCredentials: true } // Include credentials if required\n        );\n\n        const { accessToken, idToken } = response.data;\n\n        // Update tokens in storage\n        sessionStorage.setItem('accessToken', accessToken);\n        sessionStorage.setItem('idToken', idToken);\n\n        return accessToken; // Return the new access token\n    } catch (error) {\n        console.error('Token refresh failed', error);\n        throw error; // Propagate the error for the caller to handle\n    }\n};\n\nexport const clearTokens = () => {\n    sessionStorage.removeItem('accessToken');\n    sessionStorage.removeItem('idToken');\n    localStorage.removeItem('accessToken');\n    localStorage.removeItem('idToken');\n\n    document.cookie = 'refreshToken=; Max-Age=0; Secure; SameSite=Strict';\n};"],"mappings":"AAAA;AACA,SAAQA,SAAS,QAAO,YAAY;AACpC,OAAOC,KAAK,MAAM,OAAO;;AAEzB;AACA,OAAO,MAAMC,cAAc,GAAIC,KAAK,IAAK;EACrC,IAAI,CAACA,KAAK,EAAE;IACRC,OAAO,CAACC,KAAK,CAAC,uBAAuB,EAAEF,KAAK,CAAC;IAC7C,OAAO,IAAI,CAAC,CAAC;EACjB;EAEA,IAAI;IACA,MAAM;MAAEG;IAAI,CAAC,GAAGN,SAAS,CAACG,KAAK,CAAC;IAChC,MAAMI,WAAW,GAAGC,IAAI,CAACC,KAAK,CAACC,IAAI,CAACC,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC;IACjD,OAAOL,GAAG,GAAGC,WAAW;EAC5B,CAAC,CAAC,OAAOF,KAAK,EAAE;IACZD,OAAO,CAACC,KAAK,CAAC,uBAAuB,EAAEA,KAAK,CAAC;IAC7C,OAAO,IAAI,CAAC,CAAC;EACjB;AACJ,CAAC;;AAED;AACA,OAAO,MAAMO,WAAW,GAAGA,CAACC,WAAW,EAAEC,OAAO,EAAEC,YAAY,EAAEC,UAAU,GAAG,KAAK,KAAK;EACnF,IAAIA,UAAU,EAAE;IACZC,YAAY,CAACC,OAAO,CAAC,aAAa,EAAEL,WAAW,CAAC;IAChDI,YAAY,CAACC,OAAO,CAAC,SAAS,EAAEJ,OAAO,CAAC;EAC5C,CAAC,MAAM;IACHK,cAAc,CAACD,OAAO,CAAC,aAAa,EAAEL,WAAW,CAAC;IAClDM,cAAc,CAACD,OAAO,CAAC,SAAS,EAAEJ,OAAO,CAAC;EAC9C;EAEAV,OAAO,CAACgB,GAAG,CAAC,sBAAsB,EAAED,cAAc,CAACE,OAAO,CAAC,aAAa,CAAC,CAAC;EAC1EjB,OAAO,CAACgB,GAAG,CAAC,kBAAkB,EAAED,cAAc,CAACE,OAAO,CAAC,SAAS,CAAC,CAAC;;EAElE;EACA,IAAIN,YAAY,EAAE;IACdX,OAAO,CAACgB,GAAG,CAAC,kCAAkC,EAAEL,YAAY,CAAC;IAC7DO,QAAQ,CAACC,MAAM,GAAG,gBAAgBR,YAAY,oCAAoC;EACpF,CAAC,MAAM;IACLX,OAAO,CAACoB,IAAI,CAAC,4BAA4B,CAAC;EAC5C;AACN,CAAC;;AAED;AACA,OAAO,MAAMC,kBAAkB,GAAG,MAAAA,CAAOC,KAAK,EAAEX,YAAY,KAAK;EAC7D,IAAI;IACA,MAAMY,QAAQ,GAAG,MAAM1B,KAAK,CAAC2B,IAAI,CAC7B,UAAU,EACV;MAAEF,KAAK;MAAEG,aAAa,EAAEd;IAAa,CAAC,CAAE;IACxC;IACJ,CAAC;IAED,MAAM;MAAEF,WAAW;MAAEC;IAAQ,CAAC,GAAGa,QAAQ,CAACG,IAAI;;IAE9C;IACAX,cAAc,CAACD,OAAO,CAAC,aAAa,EAAEL,WAAW,CAAC;IAClDM,cAAc,CAACD,OAAO,CAAC,SAAS,EAAEJ,OAAO,CAAC;IAE1C,OAAOD,WAAW,CAAC,CAAC;EACxB,CAAC,CAAC,OAAOR,KAAK,EAAE;IACZD,OAAO,CAACC,KAAK,CAAC,sBAAsB,EAAEA,KAAK,CAAC;IAC5C,MAAMA,KAAK,CAAC,CAAC;EACjB;AACJ,CAAC;AAED,OAAO,MAAM0B,WAAW,GAAGA,CAAA,KAAM;EAC7BZ,cAAc,CAACa,UAAU,CAAC,aAAa,CAAC;EACxCb,cAAc,CAACa,UAAU,CAAC,SAAS,CAAC;EACpCf,YAAY,CAACe,UAAU,CAAC,aAAa,CAAC;EACtCf,YAAY,CAACe,UAAU,CAAC,SAAS,CAAC;EAElCV,QAAQ,CAACC,MAAM,GAAG,mDAAmD;AACzE,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}